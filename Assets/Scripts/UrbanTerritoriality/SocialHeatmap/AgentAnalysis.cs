using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UrbanTerritoriality.Agent;
using UrbanTerritoriality.Enum;

namespace UrbanTerritoriality.Maps
{
	public class AgentAnalysis : GeneralHeatmap
	{
		//public GameObject currentSimulation;
		public bool agentsMeshVisible;

		/** 
		 * How much the a cell increases in value when 
         * a single agent goes over it 
		*/
		private const float changePerNewPosition = 0.1f;

		/** This PaintGrid object is the one that is used
         * when drawing agents position. The cell values
         * in it will increase infinitelly. No normalizing is
         * done on it.
         */
		private PaintGrid workGrid;

		private int subscribedAgentsCount;
		private int events;
		private int lastEvents;
		private int deltaEvents;

		private const int eventThresholdForUpdate = 5;
		private bool firstNormalizationCompleted;

		private bool logIfAgentsOutsideMap = false;
		private bool agentsOutsideMap;

		// Store for each agent the last position used for updating the AgentAnalysis map
		// they key is an ID that uniquely identifies the agent, generated by the SimulationManager 
		private Dictionary<int, Vector3> agentLastPosition;

		public int Events
		{
			get
			{
				return events;
			}
		}

		public int SubscribedAgentsCount
		{
			get
			{
				return subscribedAgentsCount;
			}
		}

		public int DeltaEvents
		{
			get
			{
				return deltaEvents;
			}
		}

		/** Returns a value of the map at a position */
		public override float GetValueAt(Vector2 position, PathFollowingAgent agent)
		{
			Vector2Int gridpos = WorldToGridPos(position);
			if (!mPaintGrid.IsWithinGrid(gridpos.x, gridpos.y))
			{
				return mPaintGrid.defaultValue;
			}
			float val = mPaintGrid.GetValueAt(gridpos.x, gridpos.y);
			return val;
		}

		protected override void applySettings(UTSettings settings)
		{
			throw new System.NotImplementedException();
		}

		/** Do some initialization */
		protected override void _initialize()
		{
			int resX = (int)(size.x / cellSize);
			int resY = (int)(size.y / cellSize);
			mPaintGrid = new PaintGrid(resX, resY);

			workGrid = new PaintGrid(resX, resY);
			workGrid.Clear(0.0f);

			subscribedAgentsCount = 0;
			events = 0;
			lastEvents = 0;
			firstNormalizationCompleted = false;

			convergenceTimer = 0;
			base.currentTime = 0;

			agentLastPosition = new Dictionary<int, Vector3>();

			// Register to global event on-agent-spawned. Get notified everytime
			// a new agent is created into the simulation.
			SimulationManager.Instance.OnAgentSpawned.AddListener(OnAgentSpawnedHandler);
			SimulationManager.Instance.OnAgentDeSpawned.AddListener(OnAgentDeSpawnedHandler);


			logIfAgentsOutsideMap = true;

			if (logIfAgentsOutsideMap)
				StartCoroutine(logAgentsOutsideMap());
		}

		protected override void Update()
		{
			base.Update();
			deltaEvents = events - lastEvents;

			// if (events % (agentsToSpawn * 10) == 0)
			// if (deltaEvents > eventThresholdForUpdate)
			if (deltaEvents > (subscribedAgentsCount + 1) * eventThresholdForUpdate)
			{
				// Debug.Log("Normalizing...");
				meanChange = Utilities.Util.MinMaxNormalization(workGrid, mPaintGrid);
				// meanChange = Utilities.Util.ZValueNormalization(workGrid, mPaintGrid);

				// start the coroutine that handles the saving of the map
				// after the first normalization
				if (firstNormalizationCompleted == false)
				{
					_configureSaveBehavior();
					firstNormalizationCompleted = true;
				}
				lastEvents = events;
			}
		}

		// If some agent is outside of the map boundaries log a message
		// The flag is set in the UpdateCellPosition function
		// Doing in a centralized manner to preserve performances
		private IEnumerator logAgentsOutsideMap()
		{
			while (true)
			{
				if (agentsOutsideMap)
				{
					agentsOutsideMap = false;
				}
				yield return new WaitForSeconds(1 * Time.timeScale);
			}
		}

		private void OnAgentSpawnedHandler(TrackedAgent agent)
		{
			// Set agent as invisible, meaning not having any renderable
			// geometry.
			agent.SetIsVisibile(agentsMeshVisible);

			// Listen to each agent's UpdatePosition Event, when they notify
			// a new buffer of positions we update the map
			// agent.OnNewPositionsBuffer.AddListener(UpdateCellPositionWithLines);
			// Debug.Log("Subscribed to UpdateCellPosition event");
			agent.OnNewPosition.AddListener(UpdateCellPosition);
			subscribedAgentsCount++;

		}

		private void OnAgentDeSpawnedHandler(TrackedAgent agent)
		{
			agent.OnNewPosition.RemoveListener(UpdateCellPosition);
			subscribedAgentsCount--;
		}
		private void UpdateCellPosition(ChangeInPositionEventDataStructure positionData)
		{

			// get the last position, for this agent, that triggered an update in the map
			Vector3 lastRecordedPosition;
			if (agentLastPosition.TryGetValue(positionData.AgentID, out lastRecordedPosition) == false)
			{
				agentLastPosition.Add(positionData.AgentID, positionData.NewPosition);
			}
			else
			{
				Vector2Int oldMapPosition = WorldToGridPos(new Vector2(lastRecordedPosition.x, lastRecordedPosition.z));
				Vector2Int newMapPosition = WorldToGridPos(new Vector2(positionData.NewPosition.x, positionData.NewPosition.z));

				// This event can be triggered multiple times for the same position, but we only care
				// about it if we moved in the map of at least one cell
				if (oldMapPosition == newMapPosition)
					return;

				// If the position is outside the map we should not log it
				if (IsWithin(new Vector2(positionData.NewPosition.x, positionData.NewPosition.z)) == false)
				{
					agentsOutsideMap = true;    // Used for logging
					return;
				}

				float newPositionValue = workGrid.GetValueAt(newMapPosition.x, newMapPosition.y);
				newPositionValue += changePerNewPosition;
				workGrid.SetCell(newMapPosition.x, newMapPosition.y, newPositionValue);

				// If the event was processed, we update the last position of the agent that
				// triggered an update, with this current position
				agentLastPosition[positionData.AgentID] = positionData.NewPosition;

				events++;
			}
		}

		private void UpdateCellPositionWithLines(Vector3[] positions)
		{
			for (int i = 0; i < positions.Length - 1; i++)
			{
				Vector3 p1 = positions[i];
				Vector3 p2 = positions[i + 1];

				Vector2Int p1_2d = WorldToGridPos(new Vector2(p1.x, p1.z));
				Vector2Int p2_2d = WorldToGridPos(new Vector2(p2.x, p2.z));

				// the points are the same, do nothing and go next
				if (p1_2d.x == p2_2d.x && p1_2d.y == p2_2d.y)
					continue;

				else if (p1_2d.x == p2_2d.x && p1_2d.y != p2_2d.y)
				{
					// Vertical line, equation --> x = x1
					// in this case we need to color all the pixels between the two "y"
					// that have the same "x" coordinate 
					for (int y = Mathf.Min(p1_2d.y, p2_2d.y); y < Mathf.Max(p1_2d.y, p2_2d.y); y++)
					{
						int x = p1_2d.x;

						if (workGrid.IsWithinGrid(x, y))
						{
							int index = y * workGrid.Width + x;
							workGrid.grid[index] += changePerNewPosition;
						}

					}
				}
				else
				{
					// normal equation --> y = mx + q
					float m = (float)(p2_2d.y - p1_2d.y) / (p2_2d.x - p1_2d.x);
					float q = (float)((p2_2d.x * p1_2d.y) - (p1_2d.x * p2_2d.y)) / (p2_2d.x - p1_2d.x);

					float differenceBetweenXs = Mathf.Abs(p1_2d.x - p2_2d.x);
					float differenceBetweenYs = Mathf.Abs(p1_2d.y - p2_2d.y);

					// Solve line equation (segment) by fixing the "x" coordinate and getting "y" values
					if (differenceBetweenXs >= differenceBetweenYs)
					{
						int y = 0;

						// get all the points in the segment defined by the line between x1 and x2
						// and change the corresponding pixels in the paintgrid, as if the agents
						// walked a straight line between the two points
						for (int x = Mathf.Min(p1_2d.x, p2_2d.x); x < Mathf.Max(p1_2d.x, p2_2d.x); x++)
						{
							y = Mathf.RoundToInt((m * x) + q);

							if (workGrid.IsWithinGrid(x, y))
							{
								int index = y * workGrid.Width + x;
								workGrid.grid[index] += changePerNewPosition;
							}
						}
					}
					// Solve line equation (segment) by fixing the "y" coordinate and getting "x" values
					else
					{
						int x = 0;

						for (int y = Mathf.Min(p1_2d.y, p2_2d.y); y < Mathf.Max(p1_2d.y, p2_2d.y); y++)
						{
							x = Mathf.RoundToInt((y - q) / m);

							if (workGrid.IsWithinGrid(x, y))
							{
								int index = y * workGrid.Width + x;
								workGrid.grid[index] += changePerNewPosition;
							}
						}
					}
				}
				events++;

				// if (events % (agentsToSpawn * 10) == 0)
				if (events % eventThresholdForUpdate == 0)
				{
					// Debug.Log("Normalizing...");
					meanChange = Utilities.Util.Normalize(workGrid, mPaintGrid);

					// start the coroutine that handle the saving of the map
					// after the first normalization
					if (firstNormalizationCompleted == false)
					{
						_configureSaveBehavior();
						firstNormalizationCompleted = true;
					}
				}
			}
		}

		// we want to start the timer for saving the map after
		// the the first normalization, so the default function
		// should be empty (because it is called in the base class)
		protected override void ConfigureSaveBehavior()
		{

		}

		private void _configureSaveBehavior()
		{
			if ((saveAsset || saveTexture) == false)
				return;
			switch (saveMethod)
			{
				case SaveMethod.QUALITY:
					{
						StartCoroutine(SaveMapOnThreshold());
					}
					break;
				case SaveMethod.TIME:
					{
						StartCoroutine(SaveMapAfterTime());
					}
					break;
				case SaveMethod.SIMULATION_END:
					{
						SaveMapOnApplicationQuit = true;
					}
					break;
				default:
					break;
			}
		}
	}

}