using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UrbanTerritoriality.Agent;
using UrbanTerritoriality.Enum;

namespace UrbanTerritoriality.Maps
{
	public class CrowdnessAnalysis : GeneralHeatmap
	{

		/** This PaintGrid object is the one that is used
         * when drawing agents position. The cell values
         * in it will increase infinitelly. No normalizing is
         * done on it.
         */
		private PaintGrid workGrid;

		private int subscribedAgentsCount;
		private int events;
		private int lastEvents;
		private int deltaEvents;

		private const int eventThresholdForUpdate = 5;
		private bool firstNormalizationCompleted;

		// Store for each agent the last position used for updating the AgentAnalysis map
		// they key is an ID that uniquely identifies the agent, generated by the SimulationManager 
		private Dictionary<int, Vector3> agentLastPosition;

		public int SubscribedAgentsCount
		{
			get { return subscribedAgentsCount; }
			set { subscribedAgentsCount = value; }
		}

		public int DeltaEvents
		{
			get { return deltaEvents; }
			set { deltaEvents = value; }
		}

		/** Returns a value of the map at a position */
		public override float GetValueAt(Vector2 position, PathFollowingAgent agent)
		{
			Vector2Int gridpos = WorldToGridPos(position);
			if (!mPaintGrid.IsWithinGrid(gridpos.x, gridpos.y))
			{
				return mPaintGrid.defaultValue;
			}
			float val = mPaintGrid.GetValueAt(gridpos.x, gridpos.y);
			return val;
		}

		protected override void applySettings(UTSettings settings)
		{
			throw new System.NotImplementedException();
		}

		/** Do some initialization */
		protected override void _initialize()
		{
			int resX = (int)(size.x / cellSize);
			int resY = (int)(size.y / cellSize);
			mPaintGrid = new PaintGrid(resX, resY);

			workGrid = new PaintGrid(resX, resY);
			workGrid.Clear(0.0f);

			subscribedAgentsCount = 0;
			events = 0;
			firstNormalizationCompleted = false;

			convergenceTimer = 0;
			base.currentTime = 0;

			agentLastPosition = new Dictionary<int, Vector3>();

			// Register to global event on-agent-spawned. Get notified everytime
			// a new agent is created into the simulation.
			SimulationManager.Instance.OnAgentSpawned.AddListener(OnAgentSpawnedHandler);
			SimulationManager.Instance.OnAgentDeSpawned.AddListener(OnAgentDeSpawnedHandler);
		}

		private void OnAgentSpawnedHandler(TrackedAgent agent)
		{
			// Set agent as invisible, meaning not having any renderable
			// geometry.
			agent.SetIsVisibile(false);

			// Listen to each agent's UpdatePosition Event, when they notify
			// a new buffer of positions we update the map
			// agent.OnNewPositionsBuffer.AddListener(UpdateCellPositionWithLines);
			// Debug.Log("Subscribed to UpdateCellPosition event");
			agent.OnNewCrowdness.AddListener(UpdateCellCrowdness);
			subscribedAgentsCount++;

		}

		private void OnAgentDeSpawnedHandler(TrackedAgent agent)
		{
			agent.OnNewCrowdness.RemoveListener(UpdateCellCrowdness);
			subscribedAgentsCount--;
		}

		protected override void Update()
		{
			base.Update();
			deltaEvents = events - lastEvents;

			// if (events % (agentsToSpawn * 10) == 0)
			// if (deltaEvents > eventThresholdForUpdate)
			if (deltaEvents > (subscribedAgentsCount + 1) * eventThresholdForUpdate)
			{
				// Debug.Log("Normalizing...");
				meanChange = Utilities.Util.MinMaxNormalization(workGrid, mPaintGrid);
				// meanChange = Utilities.Util.ZValueNormalization(workGrid, mPaintGrid);

				// start the coroutine that handles the saving of the map
				// after the first normalization
				if (firstNormalizationCompleted == false)
				{
					_configureSaveBehavior();
					firstNormalizationCompleted = true;
				}
				lastEvents = events;
			}
		}

		private void UpdateCellCrowdness(FloatEventDataStructure crowdnessData)
		{
			// get the last position, for this agent, that triggered an update in the map
			Vector3 lastRecordedPosition;
			if (agentLastPosition.TryGetValue(crowdnessData.AgentID, out lastRecordedPosition) == false)
			{
				agentLastPosition.Add(crowdnessData.AgentID, crowdnessData.Position);
			}
			else
			{
				Vector2Int oldMapPosition = WorldToGridPos(new Vector2(lastRecordedPosition.x, lastRecordedPosition.z));
				Vector2Int newMapPosition = WorldToGridPos(new Vector2(crowdnessData.Position.x, crowdnessData.Position.z));

				// This event can be triggered multiple times for the same position, but we only care
				// about it if we moved in the map of at least one cell
				if (oldMapPosition == newMapPosition)
					return;

				// If the position is outside the map we should not log it
				if (IsWithin(new Vector2(crowdnessData.Position.x, crowdnessData.Position.z)) == false)
					return;

				// Debug.Log("UpdateCellCrowdness");


				float newCrowdnessValue = workGrid.GetValueAt(newMapPosition.x, newMapPosition.y);
				newCrowdnessValue += crowdnessData.EventValue;
				workGrid.SetCell(newMapPosition.x, newMapPosition.y, newCrowdnessValue);

				// If the event was processed, we update the last position of the agent that
				// triggered an update, with this current position
				agentLastPosition[crowdnessData.AgentID] = crowdnessData.Position;

				events++;
			}
		}

		// we want to start the timer for saving the map after
		// the the first normalization, so the default function
		// should be empty (because it is called in the base class)
		protected override void ConfigureSaveBehavior()
		{

		}

		private void _configureSaveBehavior()
		{
			if ((saveAsset || saveTexture) == false)
				return;
			switch (saveMethod)
			{
				case SaveMethod.QUALITY:
					{
						StartCoroutine(SaveMapOnThreshold());
					}
					break;
				case SaveMethod.TIME:
					{
						StartCoroutine(SaveMapAfterTime());
					}
					break;
				case SaveMethod.SIMULATION_END:
					{
						SaveMapOnApplicationQuit = true;
					}
					break;
				default:
					break;
			}
		}
	}

}